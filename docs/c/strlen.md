# 개요

문자열의 길이를 구하는 함수인 `strlen()`을 사용하면서 발생한 오류들에 대해 기록해보려고 한다.

<br />

# 시간 초과
for문 안에 `strlen()`을 사용하면 문자열이 긴 경우 시간 초과가 발생할 수 있다.
```c
// 1번. 시간 복잡도 : O(n)
int len = strlen(str);               	// O(n)
for (int i = 0; i < len; i++) { ... }	// O(n)

// 2번. 시간 복잡도 : O(n²)
for (int i = 0; i < strlen(str); i++) { ... }	// O(n) * O(n) = O(n²)
                    ...........
```
원인은 다음과 같다.
- `strlen()`은 내부적으로 0부터 `NULL`문자가 나올 때까지 읽는다.
- `strlen()`의 시간 복잡도는 문자열의 길이 n 만큼인 `O(n)`이다.
- 2번의 경우 for문의 조건을 비교할 때마다 호출되므로 시간 복잡도는 `O(n²)`이 된다.
- 1번의 경우 각 시간 복잡도를 더하면 `O(n)` + `O(n)` => `O(2n)`이므로 `O(n)` 이 된다.

**해결방법은 다음과 같다.**
- 반복 사용되는 동일한 값의 변수 및 함수는 for문 밖에서 호출하는 것을 권장한다.

<br />
<br />

# 세그먼트 오류
시작 문자열이 일부 일치하는지 확인하려다가 세그먼트 오류가 발생한 적이 있다.
```c
// 1번. 정상 소스
for (int i = 0; i < = strlen(str) - 3; i++) { ... }

// 2번. 세그먼트 오류
for (int i = 0; i < = stlen(str) - strlen("abc"); i++) { ... }
                      .........................
```
첫번째 원인은 다음과 같다.
- `strlen()`은 `size_t` 형 변수로 반환한다.
- C99 표준에서 `size_t` 형 변수는 `unsigned int` 형과 동일하다.
- 따라서, 2번의 소스는 자동 형변환에 의해 `unsigned int` 형으로 변환된다.

두번째 원인은 임의의 입력값 "ab"가 "abc" 보다 짧은 경우이다.
- 의도한 값은 `2 - 3` = `-1` 이지만 형변환에 의해 `4294967295`이 된다.
- 2번의 경우 i는 중단되지 않고 <u> 문자열 길이를 초과한 `4294967295`</u>만큼 돌게 된다.
- 즉, 잘못된 메모리를 참조하게 되어 세그먼트 에러가 발생한 것이다.

**해결방법은 다음과 같다.**
- 함수를 사용할 때는 함수의 원형을 잘 확인하자.
- 자동 형변환에 의지하지 말고 강제 캐스팅을 잘 사용하자.
